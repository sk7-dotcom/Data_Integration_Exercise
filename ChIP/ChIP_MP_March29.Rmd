---
title: "ChIP-seq data processing and analysis"
date: "07/04/2021"
author: "Meghan Peplar and Sreedevi Kesavan"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Welcome to workshop portion of today's tutorial!

This is part 2 of 3 sections towards integrating our data: ChIP-seq analysis

For more context and details on each step look under the slides folder in the main repo. 

To start we will be heading into your local terminal. 

```{bash eval = FALSE}

#Run in terminal

scp -r YOUR_FILE_PATH USERNAME@CLUSTER:home/gradstd6/Data_Int_Files .

#Folders for your intermediate outputs

cd DIRECTORY_WHERE_Data_Int_Files_LIVE

mkdir trimmed sam_out bam_out sort_bam filter_bam 

```

Depending on your rstudio setup, you will need to install the following packages for running this workshop. 

```{r eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

BiocManager::install("Rbowtie2")
BiocManager::install("Rsamtools")
BiocManager::install("bedr")
BiocManager::install("ChIPQC")

#install.packages("fastqcr")
```

To start off, set your working directory, and load the packages below. 

```{r eval = FALSE}
#Library ----

#setwd("DIRECTORY_WHERE_Data_Int_Files_LIVE") # <-- edit this based on the directory of your choice

library(Rbowtie2)
library(Rsamtools)
library(bedr)
library(ChIPQC)

#library("fastqcr") # <--- may not work with windows, fastqc code and output html has been provided.

```

Some additional folders have been populated in the scp. 

The raw_data has four fastq files (two treatment/flagged and two control/unflagged). 
The ref folder has fasta/gff files of the S. venezuelae genome. 
We have also populated the fastqc output as well as the MACS3 output so you don't have to install and run that software. 

To run your own fastqc command code has been provided below.

### First QC Step 

```{bash eval = FALSE}

fastqc MY_RAW_DATA/*.fastq -o .

scp -r USERNAME@CLUSTER:~/FASTQC_OUTPUT.html .

```

To start head to the multiqc folder and open up the .html to see the quality of the raw data. From the report generated it was clear that there was trimming to be done to remove the adapters. This is the next step in the pipeline. 

`remove_adapters()` is part of the `Rbowtie2` package and is used here to trim the adapters. 

The command requires: 

1. `file` = Path to file
2. `adapter1` = Adapter Sequence 
3. `output1` = Output Directory

We sequentially removed the first followed by the second adapter for each file, that is why the input for the second trim is from the trimmed folder. The `--minlength` flag defines the minimum length of the read after trimming. 

#### Adapter Removal

```{r eval = FALSE}
#Reads preprocessing: trimming with RBowtie2

#remove adapter 1 from flag1 file 
remove_adapters(file1 = "raw_data/flagged_v1.fastq", 
                adapter1 = "GATCGGAAGAGCGTCGTGTAGGGAAAGAGTGTAGATCTCGGTGGTCGCCG", 
                output1 = "trimmed/flagged1_adapter1")

#remove adapter 2 and filter sequences less than 76nt. Essentially here we are removing all tags from the sequencing data that still contained adapters. 

remove_adapters(file1 = "trimmed/flagged1_adapter1", 
                adapter1 = "GATCGGAAGAGCACACGTCTGAACTCCAGTCACCAGATCATCTCGTATGC", 
                output1 = "trimmed/flagged1_trimmed_filtered.fastq", "--minlength 76")

#repeat for other files, etc, etc 
remove_adapters(file1 = "raw_data/flagged_v2.fastq", 
                adapter1 = "GATCGGAAGAGCGTCGTGTAGGGAAAGAGTGTAGATCTCGGTGGTCGCCG", 
                output1 = "trimmed/flagged2_adapter1")

remove_adapters(file1 = "trimmed/flagged2_adapter1", 
                adapter1 = "GATCGGAAGAGCACACGTCTGAACTCCAGTCACCAGATCATCTCGTATGC", 
                output1 = "trimmed/flagged2_trimmed_filtered.fastq","--minlength 76")

remove_adapters(file1 = "raw_data/unflagged_control1.fastq", 
                adapter1 = "GATCGGAAGAGCGTCGTGTAGGGAAAGAGTGTAGATCTCGGTGGTCGCCG", 
                output1 = "trimmed/unflagged1_adapter1")

remove_adapters(file1 = "trimmed/unflagged1_adapter1", 
                adapter1 = "GATCGGAAGAGCACACGTCTGAACTCCAGTCACCAGATCATCTCGTATGC", 
                output1 = "trimmed/unflagged1_trimmed_filtered.fastq", "--minlength 76")

remove_adapters(file1 = "raw_data/unflagged_control2.fastq", 
                adapter1 = "GATCGGAAGAGCGTCGTGTAGGGAAAGAGTGTAGATCTCGGTGGTCGCCG",
                output1 = "trimmed/unflagged2_adapter1")

remove_adapters(file1 = "trimmed/unflagged2_adapter1", 
                adapter1 = "GATCGGAAGAGCACACGTCTGAACTCCAGTCACCAGATCATCTCGTATGC", 
                output1 = "trimmed/unflagged2_trimmed_filtered.fastq", "--minlength 76")

```

#### Second QC

Once the reads have been trimmed, repeat the fastqc step from earlier. 


#### Bowtie2 alignment to reference

Given the quality checks out OK, now we can align the reads to the S. venezuelae genome. We will use `bowtie2_build()` to generate the index and `bowtie2()` to generate the alignment. 

For the index generation you need a .fasta or .fa file that contains gene annotations. 

'build2_build()` takes the following arguments: 

1. `references` = Reference Sequence
2. `bt2Index` = Directory for the .bt2 index files

`bowtie2()` takes the following arguments:

1. `bt2Index` = Directory with the index file you just generated. 
2. `samOutput` = Output directory for the aligned .sam files
3. `seq1` = Your file from the raw_data directory 
4. `seq2` = Reverse read if available

```{r eval = FALSE}
#Read mapping with RBowtie2

bowtie2_build(references="ref/Sven_genome.fasta", bt2Index = "ref/venezuelae_bowtie")

bowtie2(bt2Index = "ref/venezuelae_bowtie", 
        samOutput = "sam_out/flagged1", 
        seq1 = "trimmed/flagged1_trimmed_filtered.fastq", 
        seq2 = NULL)

bowtie2(bt2Index = "ref/venezuelae_bowtie", 
        samOutput = "sam_out/flagged2", 
        seq1 = "trimmed/flagged2_trimmed_filtered.fastq", 
        seq2 = NULL)

bowtie2(bt2Index = "ref/venezuelae_bowtie", 
        samOutput = "sam_out/unflagged1", 
        seq1 = "trimmed/unflagged1_trimmed_filtered.fastq", 
        seq2 = NULL)

bowtie2(bt2Index = "ref/venezuelae_bowtie", 
        samOutput = "sam_out/unflagged2", 
        seq1 = "trimmed/unflagged2_trimmed_filtered.fastq", 
        seq2 = NULL)

```

#### Filtering and Sorting with RSamtools

You can learn about the structure of .sam files [here](https://samtools.github.io/hts-specs/SAMv1.pdf)

A .bam file is just a binary version of the .sam file you just created. To create .bam files we will be using the `Rsamtools` package. 

`asBam()` takes two arguements:

1. `file` = Your .sam file 
2. `destination` = Destination and .bam file name

```{r eval = FALSE}
#convert SAM to BAM

asBam(file = "sam_out/flagged1", destination = "bam_out/flagged_v1")
asBam(file = "sam_out/flagged2", destination = "bam_out/flagged_v2")
asBam(file = "sam_out/unflagged1", destination = "bam_out/unflagged_v1")
asBam(file = "sam_out/unflagged2", destination = "bam_out/unflagged_v2")

```







```{r eval = FALSE}
#add filter/sort step

sortBam(file = "bam_out/flagged_v1.bam", destination = "sort_bam/flagged_v1")
sortBam(file = "bam_out/flagged_v2.bam", destination = "sort_bam/flagged_v2")
sortBam(file = "bam_out/unflagged_v1.bam", destination = "sort_bam/unflagged_v1")
sortBam(file = "bam_out/unflagged_v2.bam", destination = "sort_bam/unflagged_v2")

indexBam("bam_out/flagged_v1.bam", "sort_bam/flagged_v1")
indexBam("bam_out/flagged_v2.bam", "sort_bam/flagged_v2")
indexBam("bam_out/unflagged_v1.bam", "sort_bam/unflagged_v1")
indexBam("bam_out/unflagged_v2.bam", "sort_bam/unflagged_v2")

filterBam(file = "sort_bam/flagged_v1.bam", 
          index = "bam_out/flagged_v1.bam.bai", 
          destination = "filter_bam/flagged1.bam")

filterBam(file = "sort_bam/flagged_v2.bam", 
          index = "bam_out/flagged_v2.bam.bai", 
          destination = "filter_bam/flagged2.bam")

filterBam(file = "sort_bam/unflagged_v1.bam", 
          index = "bam_out/unflagged_v1.bam.bai", 
          destination = "filter_bam/unflagged1.bam")

filterBam(file = "sort_bam/unflagged_v2.bam", 
          index = "bam_out/unflagged_v2.bam.bai",
          destination = "filter_bam/unflagged2.bam")
```

#### Generating Counts with MACS3

We now have some aligned .bam files. The next step is to call peaks with `MACS3`. 

In case you have not run python scripts in RStudio before, you will need to install some packages to start. 

```{r eval = FALSE}
#install.packages('reticulate')
```
You can also run it directly in your terminal - and continue with the following: 

It should be noted that you need the newest version of Python and bioconda installed on your local system to run this program. If you don't have these it can be tricky/time consuming to get them.. up to you if you want to follow along or if you want to watch and grab the output files at the end. 

```{python eval = FALSE}

conda config --add channels defaults
conda config --add channels bioconda
conda config --add channels conda-forge

conda install bwa

pip install macs3

#to run MACS3 its recommended you work in a virtual environment so that your home libraries don't get messed up 

python3 -m venv ~/Bioinfo722/Data_Integration_Exercise/ChIP/VirtualEnv
source ~/Documents/Bioinfo722/Data_Integration_Exercise/ChIP/VirtualEnv/bin/activate

#now your command should lead with something like: (VirtualEnv) (base) MeghanMacbookPro:~"

cd Documents/Bioinfo722/Data_Integration_Exercise/ChIP

#all pairwise peak comparisons
macs3 callpeak -t filter_bam/flagged1.bam -c filter_bam/unflagged1.bam -n MACS3/v1_v1 -g 8e6 --keep-dup all --mfold 2 100 

macs3 callpeak -t filter_bam/flagged1.bam -c filter_bam/unflagged2.bam -n MACS3/v1_v2 -g 8e6 --keep-dup all --mfold 2 100 

macs3 callpeak -t filter_bam/flagged2.bam -c filter_bam/unflagged1.bam -n MACS3/v2_v1 -g 8e6 --keep-dup all --mfold 2 100 

macs3 callpeak -t filter_bam/flagged2.bam -c filter_bam/unflagged2.bam -n MACS3/v2_v2 -g 8e6 --keep-dup all --mfold 2 100 

```

```{bash eval = FALSE}
#You can find the gene closest to each protein binding site (peak summit) using bedtools. I also have this installed on my local computer, but I think it exists on Brians cluster if you dont want to install it. 

bedtools closest -a MACS3/v1_v1_summits.bed -b ref/s_venezuelae.gff -t first -d > MACS3/v1v1peaks_closest_features.txt

bedtools closest -a MACS3/v1_v2_summits.bed -b ref/s_venezuelae.gff -t first -d > MACS3/v1v2peaks_closest_features.txt

bedtools closest -a MACS3/v2_v1_summits.bed -b ref/s_venezuelae.gff -t first -d > MACS3/v2v1peaks_closest_features.txt

bedtools closest -a MACS3/v2_v2_summits.bed -b ref/s_venezuelae.gff -t first -d > MACS3/v2v2peaks_closest_features.txt

#while youre working in your terminal you can also combine these files into one large file (to be duduped later)

cd MACS3/ 

cat v1v1peaks_closest_features.txt v1v2peaks_closest_features.txt v2v1peaks_closest_features.txt v2v2peaks_closest_features.txt > peaks_closest_combined.txt

#this generates a text file with all of the gene features the peaks (ID'd from the four replicates) are closest to - Repeated for each ID (i.e. if all four pairwise comparisons identidied the same gene as being closest to a peak summit, it would spit out that gene 4x)

#trim the files so you only have the columns you need. I chose to only keep the gene ID and the distance the peak summit (i.e. protein binding site) is from that gene. 

cut -f14,15 peaks_closest_combined.txt > peaks_closest_subset.txt

```
The next step is to move into R! 

Now before we do any fun integration, we have to quality check the peaks! For this we'll use the program ChIPQC. We are providing the code here to run the ChIPQC, but the .csv file needed would be different for each person and might be tedious to make. It involved populating an excel sheet with paths to the different files you are interested in quality checking (.bam and .NarrowpPeak or .bed). We've provided the output for this dataset so you can puruse without going to the trouble of running the code! 

```{r}
samples <- read.csv('ChIPQC/ChIPQC.csv')

chipObj <- ChIPQC(samples) 

ChIPQCreport(chipObj, reportName="ChIP QC report", reportFolder="~/.../ChIPQC/")

```

```{r eval = FALSE}

peaks_closest_features <- read.delim("MACS3/peaks_closest_subset.txt", header = FALSE)

#the way the GFF file is constructed we have to clean it up a little to get a table we can use for further analyses

library(tidyr)
library(dplyr)
tag <- c("tag1", "tag2")
peaks_closest_features_split <- separate(peaks_closest_features, 1, tag, sep = ";")

colnames(peaks_closest_features_split) <- c("ID", "name", "distance")

peaks_closest_trim <- select(peaks_closest_features_split, ID,  distance)

cleaned_closest <- peaks_closest_trim %>%
  mutate_if(is.character, stringr::str_replace_all, pattern = 'ID=SVEN_', replacement = '')

#now we have a nice table and we want to remove duplicates (if the same gene is ID'd by all four pairwise comparisons, just keep the one with greatest distance). 

library(data.table)
dedup_closest <- unique(setDT(cleaned_closest)[order(ID, -distance)], by = "ID")

#add info on if the genes closest to binding site are in a biosynthetic gene cluster 

Chip_table_clusters <- ChIP_table %>%
  mutate(ClusterID = case_when((ID >= 223 & ID <= 234) ~ "Ectoine",
                               (ID >= 261 & ID <= 306) ~ "Terpene1",
                               (ID >= 463 & ID <= 531) ~ "T1PKS-T3PKS-NRPS",
                               (ID >= 540 & ID <= 561) ~ "Lantipeptide/terpene"	,
                               (ID >= 612 & ID <= 630) ~ "Lantipeptide(venezuelin)",
                               (ID >= 755 & ID <= 772) ~ "Indole(acryriaflavin)",
                               (ID >= 913 & ID <= 928) ~ "Chloramphenicol",
                               (ID >= 1844 & ID <= 1884) ~ "Other1",
                               (ID >= 2566 & ID <= 2577) ~ "Siderophore(desferrioxamine-like)",
                               (ID >= 3103 & ID <= 3132) ~ "Lassopeptide",
                               (ID >= 4061 & ID <= 4110) ~ "Other2",
                               (ID >= 4179 & ID <= 4189) ~ "Butyrolactone(gaburedin)",
                               (ID >= 4620 & ID <= 4662) ~ "Melanin1",
                               (ID >= 5076 & ID <= 5111) ~ "Butyrolactone",
                               (ID >= 5119 & ID <= 5145) ~ "Thiopeptide",
                               (ID >= 5351 & ID <= 5383) ~ "T3PKS1",
                               (ID >= 5413 & ID <= 5426) ~ "Siderophore1",
                               (ID >= 5471 & ID <= 5482) ~ "Siderophore2",
                               (ID >= 5817 & ID <= 5840) ~ "Bacteriocin1",
                               (ID >= 5951 & ID <= 6002) ~ "Butyrolactone/T2PKS",
                               (ID >= 6112 & ID <= 6204) ~ "Other3",
                               (ID >= 6134 & ID <= 6282) ~ "NRPS-ladderane",
                               (ID >= 6436 & ID <= 6490) ~ "Terpene2",
                               (ID >= 6527 & ID <= 6535) ~ "Bacteriocin2",
                               (ID >= 6767 & ID <= 6814) ~ "T2PKS",
                               (ID >= 6833 & ID <= 6842) ~ "Melanin2",
                               (ID >= 7032 & ID <= 7080) ~ "NRPS",
                               (ID >= 7101 & ID <= 7119) ~ "Terpene3",
                               (ID >= 7223 & ID <= 7259) ~ "T3PKS2",
                               (ID >= 7417 & ID <= 7452) ~ "Terpene-NRPS",
                               TRUE ~ "NA"))
```








